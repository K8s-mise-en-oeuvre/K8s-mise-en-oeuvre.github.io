<!DOCTYPE html>
<html lang="fr-FR">
<head>
<meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="preload" as="font" href="https://K8s-mise-en-oeuvre.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2" type="font/woff2" crossorigin>
  <link rel="preload" as="font" href="https://K8s-mise-en-oeuvre.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2"  type="font/woff2" crossorigin>


<link rel="stylesheet" href="https://K8s-mise-en-oeuvre.github.io/main.css">



  
  
    
  

  
  
    
    
  
  
  
    
  
  
  
  
    
  
  
  


  <meta name="robots" content="index, follow">
  <meta name="googlebot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
  <meta name="bingbot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">


	


	

<title>Exploitation de Kubernetes | Kubernetes, mise en oeuvre</title>
<meta name="description" content="Documentation website of eponym course using Zola Adidoks and Github Pages">
<link rel="canonical" href="https://K8s-mise-en-oeuvre.github.io/docs/index/kubernetes-exploitation/">






  





<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BreadcrumbList",
    
      
      
        
        
        
        
        
        
        
        
          {
            "@type": "ListItem",
            "position":  1 ,
            "name": "Home",
            "item": "https://K8s-mise-en-oeuvre.github.io/"
          },
          
          
          {
            "@type": "ListItem",
            "position":  2 ,
            "name": "Docs",
            "item": "https://K8s-mise-en-oeuvre.github.io/docs/"
          },
        
      
        
        
        
        
        
        
        
        
          
          
          {
            "@type": "ListItem",
            "position":  3 ,
            "name": "Index",
            "item": "https://K8s-mise-en-oeuvre.github.io/docs/index/"
          },
        
      
        
        
        
        
        
        
        
        
        
        
        
          
          
          {
            "@type": "ListItem",
            "position":  4 ,
            "name": "Kubernetes Exploitation",
            "item": "https://K8s-mise-en-oeuvre.github.io/docs/index/kubernetes-exploitation/"
          },
        
      
    
  }
</script>




  <meta name="theme-color" content="#fff">
  <link rel="apple-touch-icon" sizes="180x180" href="https://K8s-mise-en-oeuvre.github.io/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://K8s-mise-en-oeuvre.github.io/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://K8s-mise-en-oeuvre.github.io/favicon-16x16.png">
  
    <link rel="manifest" href="https://K8s-mise-en-oeuvre.github.io/site.webmanifest">
  


  

</head>

  

<body class="docs single">
  
  
  
  
<div class="header-bar fixed-top"></div>
<header class="navbar fixed-top navbar-expand-md navbar-light">
	<div class="container">
		<input class="menu-btn order-0" type="checkbox" id="menu-btn">
		<label class="menu-icon d-md-none" for="menu-btn"><span class="navicon"></span></label>
		<a class="navbar-brand order-1 order-md-0 me-auto" href="https://K8s-mise-en-oeuvre.github.io">Kubernetes, mise en oeuvre</a>
		<button id="mode" class="btn btn-link order-2 order-md-4" type="button" aria-label="Toggle mode">
			<span class="toggle-dark"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></span>
			<span class="toggle-light"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg></span>
		</button>
		<ul class="navbar-nav fork-me order-3 order-md-5">
			
				
					<li class="nav-item">
						<a class="nav-link" href="https://github.com/K8s-mise-en-oeuvre/K8s-mise-en-oeuvre.github.io"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg><span class="ms-2 visually-hidden">GitHub</span></a>
					</li>
				
			
		</ul>
		<div class="collapse navbar-collapse order-4 order-md-1">
			<ul class="navbar-nav main-nav me-auto order-5 order-md-2">
				
					
						<li class="nav-item docs active">
							<a class="nav-link" href="https://K8s-mise-en-oeuvre.github.io/docs/index/">Docs</a>
						</li>
					
				
			</ul>
			<div class="break order-6 d-md-none"></div>
			
				<form class="navbar-form flex-grow-1 order-7 order-md-3">
					<input id="userinput" class="form-control is-search" type="search" placeholder="Search docs..."
						aria-label="Search docs..." autocomplete="off">
					<div id="suggestions" class="shadow bg-white rounded"></div>
				</form>
			
		</div>
	</div>
</header>



  
<div class="wrap container" role="document">
  <div class="content">
    <div class="row flex-xl-nowrap">
	  
<div class="col-lg-5 col-xl-4 docs-sidebar">
	<nav class="docs-links" aria-label="Main navigation">
			
			
			
			
					
					
					
							<h3>K8s, mise en oeuvre</h3>
							<ul class="list-unstyled">
							                           
									<li><a class="docs-link" href="https://K8s-mise-en-oeuvre.github.io/docs/index/containers-advanced/">Gestion avancée des containers</a></li>
							                           
									<li><a class="docs-link" href="https://K8s-mise-en-oeuvre.github.io/docs/index/kubernetes-introduction/">Introduction à kubernetes</a></li>
							                           
									<li><a class="docs-link" href="https://K8s-mise-en-oeuvre.github.io/docs/index/description-files/">Les fichiers descriptifs</a></li>
							                           
									<li><a class="docs-link" href="https://K8s-mise-en-oeuvre.github.io/docs/index/kubernetes-architecture/">Architecture Kubernetes</a></li>
							                           
									<li><a class="docs-link active" href="https://K8s-mise-en-oeuvre.github.io/docs/index/kubernetes-exploitation/">Exploitation de Kubernetes</a></li>
							                           
									<li><a class="docs-link" href="https://K8s-mise-en-oeuvre.github.io/docs/index/kubernetes-in-production/">Kubernetes en Production</a></li>
							                           
									<li><a class="docs-link" href="https://K8s-mise-en-oeuvre.github.io/docs/index/deploy-k8s-cluster/">Déploiement d&#x27;un cluster Kubernetes </a></li>
							                           
									<li><a class="docs-link" href="https://K8s-mise-en-oeuvre.github.io/docs/index/annexe-a/">Annexe A</a></li>
							
					</ul>
					
					
			
	</nav>
</div>

	  
  
  <nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation">
  	<div class="page-links">
  			<h3>On this page</h3>
  			<nav id="TableOfContents">
  					<ul>
  							
  							<li><a href="https://K8s-mise-en-oeuvre.github.io/docs/index/kubernetes-exploitation/#exploiter-kubernetes">Exploiter Kubernetes</a></li>
  							
  									<ul>
  											
  											<li><a href="https://K8s-mise-en-oeuvre.github.io/docs/index/kubernetes-exploitation/#types-de-services">Types de services</a></li>
  											
  											<li><a href="https://K8s-mise-en-oeuvre.github.io/docs/index/kubernetes-exploitation/#labels-et-choix-d-un-node-pour-le-deploiement">Labels et choix d&#x27;un node pour le déploiement</a></li>
  											
  											<li><a href="https://K8s-mise-en-oeuvre.github.io/docs/index/kubernetes-exploitation/#affinite-et-anti-affinite">Affinité et anti-affinité</a></li>
  											
  											<li><a href="https://K8s-mise-en-oeuvre.github.io/docs/index/kubernetes-exploitation/#daemons-set-health-check-config-map-et-secrets">Daemons set, health check, config map et secrets</a></li>
  											
  											<li><a href="https://K8s-mise-en-oeuvre.github.io/docs/index/kubernetes-exploitation/#persistent-volumes-et-persistent-volumes-claim">Persistent Volumes et Persistent Volumes Claim</a></li>
  											
  											<li><a href="https://K8s-mise-en-oeuvre.github.io/docs/index/kubernetes-exploitation/#deploiement-d-une-base-de-donnees-et-d-une-application-tp">Déploiement d&#x27;une base de données et d&#x27;une application (TP)</a></li>
  											
  									</ul>
  							
  							
  							<li><a href="https://K8s-mise-en-oeuvre.github.io/docs/index/kubernetes-exploitation/#tp-version-2-on-k3s-instead-of-aws">TP Version 2 (on K3s instead of AWS)</a></li>
  							
  							
  					</ul>
  			</nav>
  	</div>
  </nav>
  

      <main class="docs-content col-lg-11 col-xl-9">
        <h1>Exploitation de Kubernetes</h1>
        
        <h2 id="exploiter-kubernetes">Exploiter Kubernetes</h2>
<h3 id="types-de-services">Types de services</h3>
<blockquote>
<p>Un service est une abstraction qui <strong>définit un ensemble logique de Pods</strong> exposé à travers un endpoint. </p>
</blockquote>
<p>Il existe différents types de services :</p>
<ul>
<li>ClusterIP expose l’IP interne du cluster.</li>
<li>NodePort expose le Service sur l’IP de chaque nœud sur un port statique.</li>
<li>LoadBalancer expose le Service à l’extérieur en utilisant l’équilibreur de charge d’un fournisseur de cloud computing.</li>
<li>ExternalName associe le Service à un nom externe, tel que abc.toto.com.</li>
</ul>
<p>Le service de type ClusterIP est le service par défaut de Kubernetes. Il donne un service à l’intérieur du cluster. Les pods à l’intérieur du même cluster peuvent utiliser ce service pour y accéder. Le service de type ClusterIP ne propose pas d’accès externe.</p>
<p>Spec pour un service de type <strong>ClusterIP</strong>:</p>
<pre style="background-color:#2b303b;">
<code class="language-yaml" data-lang="yaml"><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">Service
metadata</span><span style="color:#c0c5ce;">: 
 </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">my-service
spec</span><span style="color:#c0c5ce;">:
 </span><span style="color:#bf616a;">selector</span><span style="color:#c0c5ce;">:   
   </span><span style="color:#bf616a;">app</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">toto
 type</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">ClusterIP
 ports</span><span style="color:#c0c5ce;">: 
 - </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">http
   port</span><span style="color:#c0c5ce;">: </span><span style="color:#d08770;">80
   </span><span style="color:#bf616a;">targetPort</span><span style="color:#c0c5ce;">: </span><span style="color:#d08770;">8080
   </span><span style="color:#bf616a;">protocol</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">TCP
</span></code></pre>
<p>Tous les pods à l’intérieur du cluster peuvent atteindre le pod &quot;toto&quot; sur leur port 8080 via http://my-service:80. Il est aussi possible d’atteindre le pod_b en passant par l’adresse IP du clusterIP, mais ceci n’est pas conseillé. Si il y a plusieurs pod qui ont un label &quot;app&quot; égale à &quot;toto&quot;, my-service distribue les requêtes selon une approche aléatoire.</p>
<p>Un service NodePort est le moyen le plus simple d’aiguiller du trafic externe directement vers un Pod. NodePort, comme son nom l’indique, ouvre un port spécifique sur tous les nodes, et tout trafic envoyé vers ce port est transféré vers le service.</p>
<p>Spec pour un service de <strong>NodePort</strong>:</p>
<pre style="background-color:#2b303b;">
<code class="language-yaml" data-lang="yaml"><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">Service
metadata</span><span style="color:#c0c5ce;">:
 </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">my-service
spec</span><span style="color:#c0c5ce;">:
 </span><span style="color:#bf616a;">ports</span><span style="color:#c0c5ce;">:
 - </span><span style="color:#bf616a;">port</span><span style="color:#c0c5ce;">: </span><span style="color:#d08770;">80
   </span><span style="color:#bf616a;">protocol</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">TCP
   targetPort</span><span style="color:#c0c5ce;">: </span><span style="color:#d08770;">8080
   </span><span style="color:#bf616a;">nodePort</span><span style="color:#c0c5ce;">: </span><span style="color:#d08770;">32016
 </span><span style="color:#bf616a;">selector</span><span style="color:#c0c5ce;">:
   </span><span style="color:#bf616a;">app</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">toto
 type</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">NodePort
</span></code></pre>
<p>Un service LoadBalancer est le moyen standard d’exposer un service via un load balancer. Ce type de service est particulièrement adapté aux clusters Kubernetes managés par un fournisseur cloud. Par exemple sur l’infrastructure Cloud de Google, dans un cluster GKE, cela fera tourner un loadbalancer qui donnera une adresse IP unique qui transférera tout le trafic vers votre service.</p>
<p>Spec pour un service de type <strong>LoadBalancer</strong>:</p>
<pre style="background-color:#2b303b;">
<code class="language-yaml" data-lang="yaml"><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">Service
metadata</span><span style="color:#c0c5ce;">:
 </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">my-service
spec</span><span style="color:#c0c5ce;">:
 </span><span style="color:#bf616a;">ports</span><span style="color:#c0c5ce;">:
 - </span><span style="color:#bf616a;">port</span><span style="color:#c0c5ce;">: </span><span style="color:#d08770;">80
   </span><span style="color:#bf616a;">protocol</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">TCP
   targetPort</span><span style="color:#c0c5ce;">: </span><span style="color:#d08770;">8080
 </span><span style="color:#bf616a;">selector</span><span style="color:#c0c5ce;">:
   </span><span style="color:#bf616a;">run</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">toto
 type</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">LoadBalancer
</span></code></pre><h3 id="labels-et-choix-d-un-node-pour-le-deploiement">Labels et choix d'un node pour le déploiement</h3>
<p>Pour nous intéresser plus tard à l'affinité nous devons auparavant nous intéresser au <strong>nodeSelector</strong>.</p>
<p>Le nodeSelector est une des formes de contrainte de sélection de node disponible dans Kubernetes. C'est un champ qu'on rajoute dans la spec des pods, et où on spécifie une paire de clé-valeur correspondant au label du node sur lequel on souhaite recevoir notre pod. Passons en revue un exemple d'utilisation de nodeSelector.</p>
<p>Avant toute chose, pour assigner un label à un node:</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#bf616a;">kubectl</span><span style="color:#c0c5ce;"> label node &lt;NODE_NAME&gt; &lt;key&gt;=&lt;value&gt;
</span></code></pre>
<p>Dans cet exemple je vais affecter le label ntype:toto pour mon node worker-1.</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#bf616a;">kubectl</span><span style="color:#c0c5ce;"> label node worker-1 ntype=toto
</span></code></pre>
<p>Vous pouvez vérifier que cela a fonctionné en exécutant la commande suivante:</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#bf616a;">kubectl</span><span style="color:#c0c5ce;"> get nodes worker-1</span><span style="color:#bf616a;"> --show-labels

</span><span style="color:#65737e;"># Confirmons que l&#39;on retrouve bien notre label
</span><span style="color:#bf616a;">NAME</span><span style="color:#c0c5ce;">     STATUS   ROLES    AGE   VERSION   LABELS
</span><span style="color:#bf616a;">worker-1</span><span style="color:#c0c5ce;">   Ready    &lt;none&gt;   </span><span style="color:#d08770;">82</span><span style="color:#c0c5ce;">m   v1.14.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=worker-1,kubernetes.io/os=linux,ntype=toto
</span></code></pre>
<p>L'étape suivante sera d'ajouter le champ nodeSelector à la configuration YAML de votre pod.</p>
<pre style="background-color:#2b303b;">
<code class="language-yaml" data-lang="yaml"><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">pod
metadata</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">nginx
spec</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">containers</span><span style="color:#c0c5ce;">:
  - </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">nginx
    image</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">nginx
  nodeSelector</span><span style="color:#c0c5ce;">:
    </span><span style="color:#bf616a;">ntype</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">toto
</span></code></pre>
<p>Crééons notre pod avec la commande suivante:</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#bf616a;">kubectl</span><span style="color:#c0c5ce;"> create</span><span style="color:#bf616a;"> -f</span><span style="color:#c0c5ce;"> pod.yaml
</span></code></pre>
<p>Une fois la commande lancée, le pod est alors planifié sur le node auquel vous avez attaché le label. Constatons cela avec la commande suivante:</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#bf616a;">kubectl</span><span style="color:#c0c5ce;"> get pods</span><span style="color:#bf616a;"> -o</span><span style="color:#c0c5ce;"> wide

</span><span style="color:#bf616a;">NAME</span><span style="color:#c0c5ce;">    READY   STATUS    RESTARTS   AGE     IP          NODE     NOMINATED NODE   READINESS GATES
</span><span style="color:#bf616a;">nginx</span><span style="color:#c0c5ce;">   1/1     Running   0          2m52s   10.44.0.1   worker-1   &lt;node&gt;           &lt;node&gt;
</span></code></pre>
<p>Vous pouvez supprimer le label de votre node en rajoutant le signe <strong>'-'</strong> (moins) à la fin de la commande kubectl label sans spécifier la valeur de la clé. Par exemple si je souhaite supprimer le label crée précédemment, je vais utiliser la commande suivante:</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#bf616a;">kubectl</span><span style="color:#c0c5ce;"> label node worker-1 ntype-
</span></code></pre>
<p>Nous pouvons également ordonnancer un pod sur un node spécifique via le paramètre nodeName.</p>
<p>Par exemple:</p>
<pre style="background-color:#2b303b;">
<code class="language-yaml" data-lang="yaml"><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">Pod
metadata</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">nginx
spec</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">nodeName</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">foo-node </span><span style="color:#65737e;"># schedule pod to specific node
  </span><span style="color:#bf616a;">containers</span><span style="color:#c0c5ce;">:
  - </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">nginx
    image</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">nginx
    imagePullPolicy</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">IfNotPresent
</span></code></pre>
<p>Nous pourrions par exemple souhaiter run un pod sur plusieurs nodes avec différents labels ou encore run un pod sur tous les nodes qui ne contiennent pas de tel ou tel label.</p>
<p>Néanmoins le nodeSelector ou le nodeName possèdent quelques limites. Dans notre exemple ne nous n'avions utilisé qu'un seul label de selection pour atteindre notre objectif. </p>
<p>Mais que ce passe-til si notre exigence est beaucoup plus complexe ?</p>
<p>Pour résoudre ces problématiques complexes, nous utiliserons une autre fonctionnalité proposée par kubernetes qui est l'affinité ou anti-affinité de node, que nous aborderons dans la section suivante.</p>
<h3 id="affinite-et-anti-affinite">Affinité et anti-affinité</h3>
<blockquote>
<p>La fonctionnalité d'affinité de node nous fournit des fonctionnalités avancées pour limiter le placement de pods sur des nodes spécifiques.
Dans Kubernetes, les directives relatives aux &quot;Affinités&quot; contrôlent comment les Pods sont programmés - plus regroupés ou plus dispersés.</p>
</blockquote>
<blockquote>
<p>Pour PodAffinity, vous pouvez essayer de regrouper un certain nombre de Pods dans des domaines de topologie qualifiés</p>
</blockquote>
<blockquote>
<p>Pour PodAntiAffinity, seulement un Pod peut être programmé dans un domaine de topologie unique.</p>
</blockquote>
<p>La fonctionnalité &quot;EvenPodsSpread&quot; fournit des options flexibles pour distribuer des Pods uniformément sur différents domaines de topologie - pour mettre en place de la haute disponibilité ou réduire les coûts. Cela peut aussi aider au rolling update des charges de travail et à la mise à l'échelle de réplicas.</p>
<p>Il existe actuellement deux types d'affinité de node, appelés:</p>
<p><strong>requiredDuringSchedulingIgnoredDuringExecution</strong>
<strong>preferredDuringSchedulingIgnoredDuringExecution</strong></p>
<p>On peut distinguer ces types avec les états suivants:</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#bf616a;">During</span><span style="color:#c0c5ce;"> Scheduling 	During Execution
</span><span style="color:#bf616a;">required</span><span style="color:#c0c5ce;"> 	ignored
</span><span style="color:#bf616a;">preferred</span><span style="color:#c0c5ce;"> 	ignored
</span></code></pre>
<p>Nous avons ainsi:</p>
<p><strong>During Scheduling</strong>: c'est l'état où un pod n'existe pas encore et qu'il est créé pour la première fois. </p>
<p>Cet état peut bénéficier de deux valeurs:</p>
<p><strong>required</strong>: exige que le pod soit placé sur un node respectant les règles d'affinité. S'il ne parvient pas à en trouver un, le pod ne sera alors pas planifié.</p>
<p><strong>preferred</strong>: quand aucun node correspondant n'est trouvé. Le scheduler ignorera simplement les règles d’affinité du pod et le placera sur n'importe quel node disponible.</p>
<p>C’est une façon de dire au scheduler: </p>
<blockquote>
<p>&quot;Fais de ton mieux pour placer le pod sur la correspondance d’affinité mais si tu ne peux vraiment pas en trouver un, place-le sur n’importe quel autre pod.&quot;</p>
</blockquote>
<p><strong>During Execution</strong>: c'est l'état lorsqu'un pod est déjà exécuté et qu'un changement a été apporté à l'environnement qui affecte l'affinité du node, tel qu'un changement dans le label du node. </p>
<p>Comme vous pouvez le constater, les deux types d’affinité disponibles aujourd’hui sont à l'état ingored, ce qui signifie que les pods continueront à fonctionner et que toute modification de l'affinité des nodes, n'aura aucun impact une fois qu'ils sont planifiés.</p>
<p>L'affinité de node est spécifiée dans le champ nodeAffinity du champ affinity dans la spécification du pod. Voici un exemple d'un pod utilisant une affinité de node:</p>
<pre style="background-color:#2b303b;">
<code class="language-yaml" data-lang="yaml"><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">pod
metadata</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">nginx
spec</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">affinity</span><span style="color:#c0c5ce;">:
    </span><span style="color:#bf616a;">nodeAffinity</span><span style="color:#c0c5ce;">:
      </span><span style="color:#bf616a;">requiredDuringSchedulingIgnoredDuringExecution</span><span style="color:#c0c5ce;">:
        </span><span style="color:#bf616a;">nodeSelectorTerms</span><span style="color:#c0c5ce;">:
        - </span><span style="color:#bf616a;">matchExpressions</span><span style="color:#c0c5ce;">:
          - </span><span style="color:#bf616a;">key</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">ntype
            operator</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">NotIn
            values</span><span style="color:#c0c5ce;">:
            - </span><span style="color:#bf616a;">virus
            </span><span style="color:#c0c5ce;">- </span><span style="color:#bf616a;">malware
  containers</span><span style="color:#c0c5ce;">:
  - </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">nginx
    image</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">nginx
</span></code></pre>
<p>Cette règle d'affinité de node indique que le pod ne peut pas être placé (<strong>grâce à l'opérateur NotIn</strong>) sur un node portant un label dont la clé est ntype et dont la valeur est virus ou malware.</p>
<p>Voici les différents opérateurs avec leur description pris en charge par les règles d'affinité de node:</p>
<ul>
<li>
<p><strong>In</strong> - utiliser les nodes avec les mêmes clés et valeurs à ceux qui sont définies dans le spec des pods.</p>
</li>
<li>
<p><strong>NotIn</strong> - ignorer les nodes avec les mêmes clés et valeurs à ceux qui sont définies dans le spec des pods.</p>
</li>
<li>
<p><strong>Exists</strong> - utiliser les nodes avec les mêmes clés à ceux qui sont définies dans le spec des pods.</p>
</li>
<li>
<p><strong>DoesNotExist</strong> - ignorer les nodes avec les mêmes clés à ceux qui sont définies dans le spec des pods.</p>
</li>
<li>
<p><strong>Gt</strong> - utiliser les nodes avec des valeurs numériques supérieur à ceux qui sont définies dans le spec du pod.</p>
</li>
<li>
<p><strong>Lt</strong> - utiliser les nodes avec des valeurs numériques inférieur à ceux qui sont définies dans le spec du pod.</p>
</li>
</ul>
<p>Les opérateurs <strong>NotIn</strong> et <strong>DoesNotExist</strong> provoquent ce que l'on appelle un comportement anti-affinité de node afin de respawn les pods des nodes que vous avez spécifiés. </p>
<p><em>Sources</em> </p>
<p><a href="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/">Assigning Pods to Nodes</a></p>
<p><a href="https://devopssec.fr/article/comprendre-manipuler-scheduler-kubernetes">Manipuler le scheduler Kubernetes</a></p>
<h3 id="daemons-set-health-check-config-map-et-secrets">Daemons set, health check, config map et secrets</h3>
<h4 id="daemonset">DaemonSet</h4>
<img src="https://K8s-mise-en-oeuvre.github.io/docs/persistence-daemonset.png" alt="PersistenceDaemonSet" width="900" height="720">
<blockquote>
<p>DaemonSet - Un DeamonSet est un contrôleur qui va s'assurer qu'un seul et unique pod s'exécute sur un node. C'est utile pour faire du monitoring serveur ou collecter des logs par exemple. Ainsi quand un node est ajouté au cluster, le DaemonSet va lancer lui même le pod qu'il définit.</p>
</blockquote>
<p>Vous pouvez décrire un DaemonSet dans un fichier YAML. Par exemple, le fichier daemonset.yaml ci-dessous décrit un DaemonSet qui exécute l'image Docker fluentd-elasticsearch:</p>
<pre style="background-color:#2b303b;">
<code class="language-yaml" data-lang="yaml"><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">apps/v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">DaemonSet
metadata</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">fluentd-elasticsearch
  namespace</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">kube-system
  labels</span><span style="color:#c0c5ce;">:
    </span><span style="color:#bf616a;">k8s-app</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">fluentd-logging
spec</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">selector</span><span style="color:#c0c5ce;">:
    </span><span style="color:#bf616a;">matchLabels</span><span style="color:#c0c5ce;">:
      </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">fluentd-elasticsearch
  template</span><span style="color:#c0c5ce;">:
    </span><span style="color:#bf616a;">metadata</span><span style="color:#c0c5ce;">:
      </span><span style="color:#bf616a;">labels</span><span style="color:#c0c5ce;">:
        </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">fluentd-elasticsearch
    spec</span><span style="color:#c0c5ce;">:
      </span><span style="color:#bf616a;">tolerations</span><span style="color:#c0c5ce;">:
      </span><span style="color:#65737e;"># this toleration is to have the daemonset runnable on master nodes
      # remove it if your masters can&#39;t run pods
      </span><span style="color:#c0c5ce;">- </span><span style="color:#bf616a;">key</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">node-role.kubernetes.io/master
        operator</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">Exists
        effect</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">NoSchedule
      containers</span><span style="color:#c0c5ce;">:
      - </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">fluentd-elasticsearch
        image</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">quay.io/fluentd_elasticsearch/fluentd:v2.5.2
        resources</span><span style="color:#c0c5ce;">:
          </span><span style="color:#bf616a;">limits</span><span style="color:#c0c5ce;">:
            </span><span style="color:#bf616a;">memory</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">200Mi
          requests</span><span style="color:#c0c5ce;">:
            </span><span style="color:#bf616a;">cpu</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">100m
            memory</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">200Mi
        volumeMounts</span><span style="color:#c0c5ce;">:
        - </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">varlog
          mountPath</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">/var/log
        </span><span style="color:#c0c5ce;">- </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">varlibdockercontainers
          mountPath</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">/var/lib/docker/containers
          readOnly</span><span style="color:#c0c5ce;">: </span><span style="color:#d08770;">true
      </span><span style="color:#bf616a;">terminationGracePeriodSeconds</span><span style="color:#c0c5ce;">: </span><span style="color:#d08770;">30
      </span><span style="color:#bf616a;">volumes</span><span style="color:#c0c5ce;">:
      - </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">varlog
        hostPath</span><span style="color:#c0c5ce;">:
          </span><span style="color:#bf616a;">path</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">/var/log
      </span><span style="color:#c0c5ce;">- </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">varlibdockercontainers
        hostPath</span><span style="color:#c0c5ce;">:
          </span><span style="color:#bf616a;">path</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">/var/lib/docker/containers
</span></code></pre>
<p>Puis, appliquer la spec:</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#bf616a;">kubectl</span><span style="color:#c0c5ce;"> apply</span><span style="color:#bf616a;"> -f</span><span style="color:#c0c5ce;"> https://k8s.io/examples/controllers/daemonset.yaml
</span></code></pre>
<p>Pour détruire le DaemonSet:</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#bf616a;">kubectl</span><span style="color:#c0c5ce;"> delete</span><span style="color:#bf616a;"> -f</span><span style="color:#c0c5ce;"> https://k8s.io/examples/controllers/daemonset.yaml
</span></code></pre><h4 id="healthcheck">HealthCheck</h4>
<blockquote>
<p>Afin de vérifier si un conteneur dans un pod est sain et prêt à servir le trafic, Kubernetes prévoit une série de mécanismes de contrôle de santé. Les contrôles de santé, ou sondes comme on les appelle dans Kubernetes, sont effectués par la kubelet pour déterminer quand redémarrer un conteneur (sondes de lividité) et utilisés par les services et les déploiements pour déterminer si un pod doit recevoir du trafic (sondes de disponibilité). Dans ce qui suit, nous nous concentrerons sur les contrôles de santé HTTP. </p>
</blockquote>
<p>Notez qu'il est de la responsabilité du développeur de l'application d'exposer une URL que le kubelet peut utiliser pour déterminer si le conteneur est sain (et potentiellement prêt).</p>
<p>Créons un pod qui expose un endpoint /health, répondant avec un code d'état HTTP 200:</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#bf616a;">kubectl</span><span style="color:#c0c5ce;"> apply</span><span style="color:#bf616a;"> -f</span><span style="color:#c0c5ce;"> https://raw.githubusercontent.com/openshift-evangelists/kbe/main/specs/healthz/pod.yaml
</span></code></pre>
<p>Dans la spec du pod nous avons défini ce qui suit:</p>
<pre style="background-color:#2b303b;">
<code class="language-yaml" data-lang="yaml"><span style="color:#bf616a;">livenessProbe</span><span style="color:#c0c5ce;">:
</span><span style="color:#bf616a;">initialDelaySeconds</span><span style="color:#c0c5ce;">: </span><span style="color:#d08770;">2
</span><span style="color:#bf616a;">periodSeconds</span><span style="color:#c0c5ce;">: </span><span style="color:#d08770;">5
</span><span style="color:#bf616a;">httpGet</span><span style="color:#c0c5ce;">:
</span><span style="color:#bf616a;">path</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">/health
port</span><span style="color:#c0c5ce;">: </span><span style="color:#d08770;">9876
</span></code></pre>
<p>La configuration ci-dessus indique à Kubernetes de commencer à vérifier le point de terminaison <strong>/health</strong>, après avoir initialement attendu 2 secondes, toutes les 5 secondes. </p>
<p>Si nous regardons maintenant le pod, nous pouvons voir qu'il est considéré comme sain:</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#bf616a;">kubectl</span><span style="color:#c0c5ce;"> describe pod hc

</span><span style="color:#bf616a;">Name:</span><span style="color:#c0c5ce;">         hc
</span><span style="color:#bf616a;">Namespace:</span><span style="color:#c0c5ce;">    default
</span><span style="color:#bf616a;">Priority:</span><span style="color:#c0c5ce;">     0
</span><span style="color:#bf616a;">Node:</span><span style="color:#c0c5ce;">         minikube/192.168.39.51
</span><span style="color:#bf616a;">...
Containers:
  sise:
    Container</span><span style="color:#c0c5ce;"> ID:   docker://2cfe4187808a89ae4731abfe242ac42611e1f658505691f540ac31ca8f6ce86f
    </span><span style="color:#bf616a;">Image:</span><span style="color:#c0c5ce;">          quay.io/openshiftlabs/simpleservice:0.5.0
    </span><span style="color:#bf616a;">...
    Ready:</span><span style="color:#c0c5ce;">          True
    </span><span style="color:#bf616a;">Restart</span><span style="color:#c0c5ce;"> Count:  0
    </span><span style="color:#bf616a;">Liveness:</span><span style="color:#c0c5ce;">       http-get http://:9876/health delay=2s timeout=1s period=5s </span><span style="color:#65737e;">#success=1 #failure=3
</span><span style="color:#c0c5ce;">    Environment:    &lt;none&gt;
Conditions:
  </span><span style="color:#bf616a;">Type</span><span style="color:#c0c5ce;">              Status
  </span><span style="color:#bf616a;">Initialized</span><span style="color:#c0c5ce;">       True 
  </span><span style="color:#bf616a;">Ready</span><span style="color:#c0c5ce;">             True 
  </span><span style="color:#bf616a;">ContainersReady</span><span style="color:#c0c5ce;">   True 
  </span><span style="color:#bf616a;">PodScheduled</span><span style="color:#c0c5ce;">      True 
</span><span style="color:#bf616a;">...
</span></code></pre>
<p><em>Source</em> <a href="https://kubebyexample.com/en/concept/health-checks">HealthChecks Kube By Example</a></p>
<h4 id="configmap">ConfigMap</h4>
<blockquote>
<p>Une ConfigMap est un objet d'API utilisé pour stocker des données non confidentielles dans des paires clé-valeur. Les pods peuvent utiliser les ConfigMaps comme variables d'environnement, arguments de ligne de commande ou fichiers de configuration dans un volume.
Un ConfigMap vous permet de découpler la configuration spécifique à l'environnement de vos images de conteneur, afin que vos applications soient facilement portables.</p>
</blockquote>
<p>Typiquement, nous pourrions renseigner en tant que ConfigMap les fichiers de configuration de nos bases de données.</p>
<p>Utilisez une ConfigMap pour définir les données de configuration séparément du code de l'application.</p>
<p>Par exemple, imaginez que vous développez une application que vous pouvez exécuter sur votre propre ordinateur (pour le développement) et dans le cloud (pour gérer le trafic réel). Vous écrivez le code pour chercher dans une variable d'environnement appelée DATABASE_HOST. Localement, vous attribuez à cette variable la valeur localhost. Dans le nuage, vous la définissez pour faire référence à un service Kubernetes qui expose le composant de base de données à votre cluster. Cela vous permet de récupérer une image de conteneur exécutée dans le nuage et de déboguer le même code localement si nécessaire.</p>
<p>Une ConfigMap n'est pas conçue pour contenir de grandes quantités de données. Les données stockées dans une ConfigMap ne peuvent pas dépasser 1 Mo. Si vous devez stocker des paramètres dont la taille dépasse cette limite, vous pouvez envisager de monter un volume ou d'utiliser une base de données ou un service de fichiers distinct.</p>
<p>Créer un objet ConfigMap et définissez la spec d'un pod utilisant cette ConfigMap:</p>
<pre style="background-color:#2b303b;">
<code class="language-yaml" data-lang="yaml"><span style="color:#65737e;"># cm.yaml
# ConfigMap
</span><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">ConfigMap
metadata</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">game-demo
data</span><span style="color:#c0c5ce;">:
  </span><span style="color:#65737e;"># property-like keys; each key maps to a simple value
  </span><span style="color:#bf616a;">player_initial_lives</span><span style="color:#c0c5ce;">: &quot;</span><span style="color:#a3be8c;">3</span><span style="color:#c0c5ce;">&quot;
  </span><span style="color:#bf616a;">ui_properties_file_name</span><span style="color:#c0c5ce;">: &quot;</span><span style="color:#a3be8c;">user-interface.properties</span><span style="color:#c0c5ce;">&quot;

  </span><span style="color:#65737e;"># file-like keys
  </span><span style="color:#bf616a;">game.properties</span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">|
</span><span style="color:#a3be8c;">    enemy.types=aliens,monsters
    player.maximum-lives=5    
  </span><span style="color:#bf616a;">user-interface.properties</span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">|
</span><span style="color:#a3be8c;">    color.good=purple
    color.bad=yellow
    allow.textmode=true
</span><span style="color:#c0c5ce;">---
</span><span style="color:#65737e;"># Pod
</span><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">Pod
metadata</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">configmap-demo-pod
spec</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">containers</span><span style="color:#c0c5ce;">:
    - </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">demo
      image</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">alpine
      command</span><span style="color:#c0c5ce;">: [&quot;</span><span style="color:#a3be8c;">sleep</span><span style="color:#c0c5ce;">&quot;, &quot;</span><span style="color:#a3be8c;">3600</span><span style="color:#c0c5ce;">&quot;]
      </span><span style="color:#bf616a;">env</span><span style="color:#c0c5ce;">:
        </span><span style="color:#65737e;"># Define the environment variable
        </span><span style="color:#c0c5ce;">- </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">PLAYER_INITIAL_LIVES </span><span style="color:#65737e;"># Notice that the case is different here
                                     # from the key name in the ConfigMap.
          </span><span style="color:#bf616a;">valueFrom</span><span style="color:#c0c5ce;">:
            </span><span style="color:#bf616a;">configMapKeyRef</span><span style="color:#c0c5ce;">:
              </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">game-demo           </span><span style="color:#65737e;"># The ConfigMap this value comes from.
              </span><span style="color:#bf616a;">key</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">player_initial_lives </span><span style="color:#65737e;"># The key to fetch.
        </span><span style="color:#c0c5ce;">- </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">UI_PROPERTIES_FILE_NAME
          valueFrom</span><span style="color:#c0c5ce;">:
            </span><span style="color:#bf616a;">configMapKeyRef</span><span style="color:#c0c5ce;">:
              </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">game-demo
              key</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">ui_properties_file_name
      volumeMounts</span><span style="color:#c0c5ce;">:
      - </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">config
        mountPath</span><span style="color:#c0c5ce;">: &quot;</span><span style="color:#a3be8c;">/config</span><span style="color:#c0c5ce;">&quot;
        </span><span style="color:#bf616a;">readOnly</span><span style="color:#c0c5ce;">: </span><span style="color:#d08770;">true
  </span><span style="color:#bf616a;">volumes</span><span style="color:#c0c5ce;">:
    </span><span style="color:#65737e;"># You set volumes at the Pod level, then mount them into containers inside that Pod
    </span><span style="color:#c0c5ce;">- </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">config
      configMap</span><span style="color:#c0c5ce;">:
        </span><span style="color:#65737e;"># Provide the name of the ConfigMap you want to mount.
        </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">game-demo
        </span><span style="color:#65737e;"># An array of keys from the ConfigMap to create as files
        </span><span style="color:#bf616a;">items</span><span style="color:#c0c5ce;">:
        - </span><span style="color:#bf616a;">key</span><span style="color:#c0c5ce;">: &quot;</span><span style="color:#a3be8c;">game.properties</span><span style="color:#c0c5ce;">&quot;
          </span><span style="color:#bf616a;">path</span><span style="color:#c0c5ce;">: &quot;</span><span style="color:#a3be8c;">game.properties</span><span style="color:#c0c5ce;">&quot;
        - </span><span style="color:#bf616a;">key</span><span style="color:#c0c5ce;">: &quot;</span><span style="color:#a3be8c;">user-interface.properties</span><span style="color:#c0c5ce;">&quot;
          </span><span style="color:#bf616a;">path</span><span style="color:#c0c5ce;">: &quot;</span><span style="color:#a3be8c;">user-interface.properties</span><span style="color:#c0c5ce;">&quot;
</span></code></pre><pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#bf616a;">kubectl</span><span style="color:#c0c5ce;"> apply</span><span style="color:#bf616a;"> -f</span><span style="color:#c0c5ce;"> cm.yaml
</span></code></pre>
<p>Pour détruire les ressources:</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#bf616a;">kubectl</span><span style="color:#c0c5ce;"> delete</span><span style="color:#bf616a;"> -f</span><span style="color:#c0c5ce;"> cm.yaml
</span></code></pre><h4 id="secrets">Secrets</h4>
<blockquote>
<p>Les objets secret de Kubernetes vous permettent de stocker et de gérer des informations sensibles, telles que les mots de passe, les tokens OAuth et les clés ssh. Mettre ces informations dans un secret est plus sûr et plus flexible que de le mettre en dur dans la définition d'un Pod ou dans une image de container.</p>
</blockquote>
<p>Un secret est un objet qui contient une petite quantité de données sensibles telles qu'un mot de passe, un token ou une clé. De telles informations pourraient autrement être placées dans une spécification de pod ou dans une image; le placer dans un objet secret permet de mieux contrôler la façon dont il est utilisé et réduit le risque d'exposition accidentelle.</p>
<p>Les utilisateurs peuvent créer des secrets et le système crée également des secrets.</p>
<p>Pour utiliser un secret, un pod doit référencer le secret. Un secret peut être utilisé avec un pod de deux manières: sous forme de fichiers dans un volume monté sur un ou plusieurs de ses conteneurs, ou utilisé par kubelet lorsque vous récupérez des images pour le pod.</p>
<p>Vous pouvez également créer un secret dans un fichier d'abord, au format json ou yaml, puis créer cet objet. Le secret contient deux table de hachage: data et stringData. Le champ data est utilisé pour stocker des données arbitraires, encodées en base64. Le champ stringData est fourni pour plus de commodité et vous permet de fournir des données secrètes sous forme de chaînes non codées.</p>
<p>Par exemple, pour stocker deux chaînes dans un secret à l'aide du champ data, convertissez-les en base64 comme suit:</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#96b5b4;">echo </span><span style="color:#bf616a;">-n </span><span style="color:#c0c5ce;">&#39;</span><span style="color:#a3be8c;">admin</span><span style="color:#c0c5ce;">&#39; | </span><span style="color:#bf616a;">base64
YWRtaW4</span><span style="color:#c0c5ce;">=
</span><span style="color:#96b5b4;">echo </span><span style="color:#bf616a;">-n </span><span style="color:#c0c5ce;">&#39;</span><span style="color:#a3be8c;">1f2d1e2e67df</span><span style="color:#c0c5ce;">&#39; | </span><span style="color:#bf616a;">base64
MWYyZDFlMmU2N2Rm
</span></code></pre>
<p>Écrivez un secret qui ressemble à ceci:</p>
<pre style="background-color:#2b303b;">
<code class="language-yaml" data-lang="yaml"><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">Secret
metadata</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">mysecret
type</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">Opaque
data</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">username</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">YWRtaW4=
  password</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">MWYyZDFlMmU2N2Rm
</span></code></pre>
<p>Maintenant, créez le secret en utilisant <code>kubectl apply</code>:</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#bf616a;">kubectl</span><span style="color:#c0c5ce;"> apply</span><span style="color:#bf616a;"> -f</span><span style="color:#c0c5ce;"> ./secret.yaml

</span><span style="color:#bf616a;">secret </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">mysecret</span><span style="color:#c0c5ce;">&quot; created
</span></code></pre>
<p>Pour certains scénarios, vous pouvez utiliser le champ stringData à la place. Ce champ vous permet de mettre une chaîne non codée en base64 directement dans le secret, et la chaîne sera codée pour vous lorsque le secret sera créé ou mis à jour.</p>
<p>Un exemple pratique de cela pourrait être le suivant: vous déployez une application qui utilise un secret pour stocker un fichier de configuration. Vous souhaitez remplir des parties de ce fichier de configuration pendant votre processus de déploiement.</p>
<p>Si votre application utilise le fichier de configuration suivant:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">apiUrl: &quot;https://my.api.com/api/v1&quot;
username: &quot;user&quot;
password: &quot;password&quot;
</span></code></pre>
<p>Vous pouvez stocker cela dans un secret en utilisant ce qui suit:</p>
<pre style="background-color:#2b303b;">
<code class="language-yaml" data-lang="yaml"><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">Secret
metadata</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">mysecret
type</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">Opaque
stringData</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">config.yaml</span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">|-
</span><span style="color:#a3be8c;">    apiUrl: &quot;https://my.api.com/api/v1&quot;
    username: {{username}}
    password: {{password}}    
</span></code></pre>
<p>Votre outil de déploiement pourrait alors remplacer les variables de modèle {{username}} et {{password}} avant d'exécuter <code>kubectl apply</code>.</p>
<p>stringData est un champ de commodité en écriture seule. Il n'est jamais affiché lors de la récupération des secrets. Par exemple, si vous exécutez la commande suivante:</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#bf616a;">kubectl</span><span style="color:#c0c5ce;"> get secret mysecret</span><span style="color:#bf616a;"> -o</span><span style="color:#c0c5ce;"> yaml
</span></code></pre>
<p>L'output généré sera alors:</p>
<pre style="background-color:#2b303b;">
<code class="language-yaml" data-lang="yaml"><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">Secret
metadata</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">creationTimestamp</span><span style="color:#c0c5ce;">: </span><span style="color:#d08770;">2021-11-15T20:40:59Z
  </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">mysecret
  namespace</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">default
  resourceVersion</span><span style="color:#c0c5ce;">: &quot;</span><span style="color:#a3be8c;">7225</span><span style="color:#c0c5ce;">&quot;
  </span><span style="color:#bf616a;">uid</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">c280ad2e-e916-11e8-98f2-025000000001
type</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">Opaque
data</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">config.yaml</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">YXBpVXJsOiAiaHR0cHM6Ly9teS5hcGkuY29tL2FwaS92MSIKdXNlcm5hbWU6IHt7dXNlcm5hbWV9fQpwYXNzd29yZDoge3twYXNzd29y
</span></code></pre>
<p>Pour décoder un secret nous aurons besoin de récupérer le secret créé via la command <code>kubectl get secret</code>.</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#bf616a;">kubectl</span><span style="color:#c0c5ce;"> get secret mysecret</span><span style="color:#bf616a;"> -o</span><span style="color:#c0c5ce;"> yaml
</span></code></pre><pre style="background-color:#2b303b;">
<code class="language-yaml" data-lang="yaml"><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">Secret
metadata</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">creationTimestamp</span><span style="color:#c0c5ce;">: </span><span style="color:#d08770;">2021-01-22T18:41:56Z
  </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">mysecret
  namespace</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">default
  resourceVersion</span><span style="color:#c0c5ce;">: &quot;</span><span style="color:#a3be8c;">164619</span><span style="color:#c0c5ce;">&quot;
  </span><span style="color:#bf616a;">uid</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">cfee02d6-c137-11e5-8d73-42010af00002
type</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">Opaque
data</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">username</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">YWRtaW4=
  password</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">MWYyZDFlMmU2N2Rm
</span></code></pre>
<p>Décodez le champ du mot de passe:</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#96b5b4;">echo </span><span style="color:#c0c5ce;">&#39;</span><span style="color:#a3be8c;">MWYyZDFlMmU2N2Rm</span><span style="color:#c0c5ce;">&#39; | </span><span style="color:#bf616a;">base64 --decode

1f2d1e2e67df
</span></code></pre><h3 id="persistent-volumes-et-persistent-volumes-claim">Persistent Volumes et Persistent Volumes Claim</h3>
<p>La gestion du stockage est un problème distinct de la gestion du compute. </p>
<p>Le sous-système PersistentVolume fournit aux utilisateurs et aux administrateurs une API qui fait abstraction des détails sur la façon dont le stockage est fourni et sur la façon dont il est consommé. </p>
<p>Pour ce faire, nous introduisons deux nouvelles ressources API: <strong>PersistentVolume et PersistentVolumeClaim</strong>.</p>
<blockquote>
<p>Un PersistentVolume (PV) est un élément de stockage en réseau dans le cluster qui a été provisionné par un administrateur. Il s'agit d'une ressource du cluster, tout comme un nœud est une ressource du cluster. Les PV sont des plugins de volume comme les volumes, mais ont un cycle de vie indépendant de tout pod individuel qui utilise le PV. Cet objet API capture les détails de l'implémentation du stockage, qu'il s'agisse de NFS, d'iSCSI ou d'un système de stockage spécifique au fournisseur de cloud.</p>
</blockquote>
<blockquote>
<p>Une PersistentVolumeClaim (PVC) est une demande de stockage par un utilisateur. Elle est similaire à un pod. Les pods consomment des ressources de nœuds et les PVC des ressources de PV. Les pods peuvent demander des niveaux spécifiques de ressources (CPU et mémoire). Les revendications peuvent demander une taille et des modes d'accès spécifiques (par exemple, peuvent être montées une fois en lecture/écriture ou plusieurs fois en lecture seule).</p>
</blockquote>
<p>Alors que les PersistentVolumeClaims permettent à un utilisateur de consommer des ressources de stockage abstraites, il est courant que les utilisateurs aient besoin de PersistentVolumes avec des propriétés variables, telles que la performance, pour différents problèmes. </p>
<p>Les administrateurs de clusters doivent être en mesure d'offrir une variété de PersistentVolumes qui diffèrent en plus de la taille et des modes d'accès, sans exposer les utilisateurs aux détails de l'implémentation de ces volumes. </p>
<p>Pour ces besoins, il existe la ressource StorageClass.</p>
<blockquote>
<p>Une StorageClass permet aux administrateurs de décrire les &quot;classes&quot; de stockage qu'ils proposent. Les différentes classes peuvent correspondre à des niveaux de qualité de service, à des politiques de sauvegarde ou à des politiques arbitraires déterminées par les administrateurs du cluster. Kubernetes lui-même ne se prononce pas sur ce que représentent les classes. Ce concept est parfois appelé &quot;profils&quot; dans d'autres systèmes de stockage.</p>
</blockquote>
<p>Quelques types de plugins pour persistent volumes:</p>
<ul>
<li>GCEPersistentDisk</li>
<li>AWSElasticBlockStore</li>
<li>AzureFile</li>
<li>AzureDisk</li>
<li>FC (Fibre Channel)</li>
<li>Flocker</li>
<li>NFS</li>
<li>iSCSI</li>
<li>RBD (Ceph Block Device)</li>
<li>CephFS</li>
<li>Cinder (OpenStack block storage)</li>
<li>Glusterfs</li>
<li>VsphereVolume</li>
<li>Quobyte Volumes</li>
<li>HostPath (tester sur un seul nœud uniquement - le stockage local n'est en aucun cas pris en charge et ne fonctionnera pas dans un cluster multi-nœuds)</li>
<li>VMware Photon</li>
<li>Portworx Volumes</li>
<li>ScaleIO Volumes</li>
</ul>
<p>Les plug-ins de volume suivants prennent en charge les volumes de blocs bruts, y compris l'approvisionnement dynamique, le cas échéant:</p>
<ul>
<li>AWSElasticBlockStore</li>
<li>AzureDisk</li>
<li>FC (Fibre Channel)</li>
<li>GCEPersistentDisk</li>
<li>iSCSI</li>
<li>Local volume</li>
<li>RBD (Ceph Block Device)</li>
<li>VsphereVolume (alpha)</li>
</ul>
<blockquote>
<p>Seuls les volumes FC et iSCSI prennent en charge les volumes de blocs bruts dans Kubernetes 1.9. La prise en charge des plugins supplémentaires a été ajoutée dans 1.10. </p>
</blockquote>
<p>Se référer à la documentation spécifique a chaque plugin pour déterminer la spec permettant leur uitlisation.</p>
<p>Pour des volumes persistants utilisant un volume de bloc brut:</p>
<pre style="background-color:#2b303b;">
<code class="language-yaml" data-lang="yaml"><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">PersistentVolume
metadata</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">block-pv
spec</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">capacity</span><span style="color:#c0c5ce;">:
    </span><span style="color:#bf616a;">storage</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">10Gi
  accessModes</span><span style="color:#c0c5ce;">:
    - </span><span style="color:#bf616a;">ReadWriteOnce
  volumeMode</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">Block
  persistentVolumeReclaimPolicy</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">Retain
  fc</span><span style="color:#c0c5ce;">:
    </span><span style="color:#bf616a;">targetWWNs</span><span style="color:#c0c5ce;">: [&quot;</span><span style="color:#a3be8c;">50060e801049cfd1</span><span style="color:#c0c5ce;">&quot;]
    </span><span style="color:#bf616a;">lun</span><span style="color:#c0c5ce;">: </span><span style="color:#d08770;">0
    </span><span style="color:#bf616a;">readOnly</span><span style="color:#c0c5ce;">: </span><span style="color:#d08770;">false
</span></code></pre>
<p>Revendication de volume persistant demandant un volume de bloc brut:</p>
<pre style="background-color:#2b303b;">
<code class="language-yaml" data-lang="yaml"><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">PersistentVolumeClaim
metadata</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">block-pvc
spec</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">accessModes</span><span style="color:#c0c5ce;">:
    - </span><span style="color:#bf616a;">ReadWriteOnce
  volumeMode</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">Block
  resources</span><span style="color:#c0c5ce;">:
    </span><span style="color:#bf616a;">requests</span><span style="color:#c0c5ce;">:
      </span><span style="color:#bf616a;">storage</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">10Gi
</span></code></pre>
<p>Spécification de pod ajoutant le chemin du périphérique de bloc brut dans le conteneur:</p>
<pre style="background-color:#2b303b;">
<code class="language-yaml" data-lang="yaml"><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">Pod
metadata</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">pod-with-block-volume
spec</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">containers</span><span style="color:#c0c5ce;">:
    - </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">fc-container
      image</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">fedora:26
      command</span><span style="color:#c0c5ce;">: [&quot;</span><span style="color:#a3be8c;">/bin/sh</span><span style="color:#c0c5ce;">&quot;, &quot;</span><span style="color:#a3be8c;">-c</span><span style="color:#c0c5ce;">&quot;]
      </span><span style="color:#bf616a;">args</span><span style="color:#c0c5ce;">: [ &quot;</span><span style="color:#a3be8c;">tail -f /dev/null</span><span style="color:#c0c5ce;">&quot; ]
      </span><span style="color:#bf616a;">volumeDevices</span><span style="color:#c0c5ce;">:
        - </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">data
          devicePath</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">/dev/xvda
  volumes</span><span style="color:#c0c5ce;">:
    - </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">data
      persistentVolumeClaim</span><span style="color:#c0c5ce;">:
        </span><span style="color:#bf616a;">claimName</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">block-pvc
</span></code></pre>
<p><em>N.B.</em> Lorsque vous ajoutez un périphérique de bloc brut pour un pod, vous spécifiez le chemin de périphérique dans le conteneur au lieu d'un chemin de montage.</p>
<p><em>Sources</em> </p>
<p><a href="https://unofficial-kubernetes.readthedocs.io/en/latest/concepts/storage/persistent-volumes/">Unoffical K8s: persistent volumes</a></p>
<p><a href="https://kubernetes.io/fr/docs/concepts/storage/persistent-volumes/">Concepts: Persistent Volumes</a></p>
<h3 id="deploiement-d-une-base-de-donnees-et-d-une-application-tp">Déploiement d'une base de données et d'une application (TP)</h3>
<p>Vos disposez de la spec suivante qui définit respectivement:</p>
<ul>
<li>un PVC qui crée automatiquement le PV associé via la storage-class local-path</li>
</ul>
<p>Vous devrez définir:</p>
<ul>
<li>un service mysql</li>
<li>une configmap pour un fichier de configuration de votre choix</li>
<li>un secret pour notre db</li>
<li>le deployment de notre db</li>
</ul>
<p>Vous aurez à charge d'écrire la spec du deployment du service et du secret mysql correspondant. N'hésitez pas pour ce faire à vous repportez à la section &quot;Syntaxe YAML&quot;.</p>
<p><em>mysql-full-resources.yaml</em></p>
<pre style="background-color:#2b303b;">
<code class="language-yaml" data-lang="yaml"><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">storage.k8s.io/v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">StorageClass
metadata</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">ebs-storage-class
provisioner</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">kubernetes.io/aws-ebs
parameters</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">type</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">io1
  iopsPerGB</span><span style="color:#c0c5ce;">: &#39;</span><span style="color:#a3be8c;">10</span><span style="color:#c0c5ce;">&#39;
  </span><span style="color:#bf616a;">fsType</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">xfs
</span><span style="color:#c0c5ce;">---
</span><span style="color:#bf616a;">kind</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">PersistentVolumeClaim
apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
metadata</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">ebs-pvc
  namespace</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">default
spec</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">accessModes</span><span style="color:#c0c5ce;">:
    - </span><span style="color:#bf616a;">ReadWriteOnce
  resources</span><span style="color:#c0c5ce;">:
    </span><span style="color:#bf616a;">requests</span><span style="color:#c0c5ce;">:
      </span><span style="color:#bf616a;">storage</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">5Gi
  storageClassName</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">ebs-storage-class
</span><span style="color:#c0c5ce;">---
</span><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">apps/v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">Deployment
</span><span style="color:#65737e;"># Completer ce qui suit
</span><span style="color:#c0c5ce;">---
</span><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">ConfigMap
</span><span style="color:#65737e;"># Completer ce qui suit
</span><span style="color:#c0c5ce;">---
</span><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">Service
</span><span style="color:#65737e;"># Completer ce qui suit
</span><span style="color:#c0c5ce;">---
</span><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">Secret
</span><span style="color:#65737e;"># Completer ce qui suit
</span></code></pre><pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#bf616a;">kubectl</span><span style="color:#c0c5ce;"> apply mysql-full-resources.yaml
</span></code></pre>
<p><em>Facultatif</em>: Réécrivez les specs en utilisant une autre classe de storage que celle définie précédemment (kubernetes.io/aws-ebs) et créer le PV et le PVC en conséquence.</p>
<h2 id="tp-version-2-on-k3s-instead-of-aws">TP Version 2 (on K3s instead of AWS)</h2>
<p>Vos disposez de la spec suivante qui définit respectivement:</p>
<ul>
<li>un PVC qui crée automatiquement le PV associé via la storage-class local-path</li>
</ul>
<p>Vous devrez définir:</p>
<ul>
<li>un service mysql</li>
<li>un secret pour notre db</li>
<li>le deployment de notre db</li>
</ul>
<p>Vous aurez à charge d'écrire la spec du deployment du service et du secret mysql correspondant. N'hésitez pas pour ce faire à vous repportez à la section &quot;Syntaxe YAML&quot;.</p>
<p><em>mysql-full-resources.yaml</em></p>
<pre style="background-color:#2b303b;">
<code class="language-yaml" data-lang="yaml"><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">PersistentVolumeClaim
metadata</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">local-path-pvc
  namespace</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">default
spec</span><span style="color:#c0c5ce;">:
  </span><span style="color:#bf616a;">accessModes</span><span style="color:#c0c5ce;">:
    - </span><span style="color:#bf616a;">ReadWriteOnce
  storageClassName</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">local-path
  resources</span><span style="color:#c0c5ce;">:
    </span><span style="color:#bf616a;">requests</span><span style="color:#c0c5ce;">:
      </span><span style="color:#bf616a;">storage</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">2Gi
</span><span style="color:#c0c5ce;">---
</span><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">apps/v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">Deployment
</span><span style="color:#65737e;"># Completer ce qui suit
</span><span style="color:#c0c5ce;">---
</span><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">ConfigMap
</span><span style="color:#65737e;"># Completer ce qui suit
</span><span style="color:#c0c5ce;">---
</span><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">Service
</span><span style="color:#65737e;"># Completer ce qui suit
</span><span style="color:#c0c5ce;">---
</span><span style="color:#bf616a;">apiVersion</span><span style="color:#c0c5ce;">: </span><span style="color:#bf616a;">v1
kind</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">Secret
</span><span style="color:#65737e;"># Completer ce qui suit
</span></code></pre><pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#bf616a;">kubectl</span><span style="color:#c0c5ce;"> apply mysql-full-resources.yaml
</span></code></pre>
<p><em>Facultatif</em>: Réécrivez les specs en utilisant une autre classe de storage que celle définie précédemment (local-path) et créer le PV et le PVC en conséquence.</p>

        
        
<div class="docs-navigation d-flex justify-content-between">
  
  
  
  
  
  <a href="https:&#x2F;&#x2F;K8s-mise-en-oeuvre.github.io&#x2F;docs&#x2F;index&#x2F;kubernetes-architecture&#x2F;">
    <div class="card my-1">
      <div class="card-body py-2">
        &larr; Architecture Kubernetes
      </div>
    </div>
  </a>
  

  
  
  
  
  
    <a class="ms-auto" href="https:&#x2F;&#x2F;K8s-mise-en-oeuvre.github.io&#x2F;docs&#x2F;index&#x2F;kubernetes-in-production&#x2F;">
      <div class="card my-1">
        <div class="card-body py-2">
          Kubernetes en Production &rarr;
        </div>
      </div>
    </a>
  
</div>

      </main>
    </div>
  </div>
</div>


  
    
<footer class="footer text-muted">
	<div class="container">
		<div class="row">
			<div class="col-lg-8 order-last order-lg-first">
				<ul class="list-inline">
					
						<li class="list-inline-item">Powered by <a href="https://www.getzola.org/">Zola</a>, and <a href="https://github.com/aaranxu/adidoks">AdiDoks</a></li>
					
				</ul>
			</div>
			<div class="col-lg-8 order-first order-lg-last text-lg-end">
				<ul class="list-inline">
					
				</ul>
			</div>
		</div>
	</div>
</footer>

  

  
<script src="https://K8s-mise-en-oeuvre.github.io/js/main.js" defer></script>

  <script src="https://K8s-mise-en-oeuvre.github.io/plugins/elasticlunr.min.js" defer></script>
  <script src="https://K8s-mise-en-oeuvre.github.io/search_index.fr.js" defer></script>
  <script src="https://K8s-mise-en-oeuvre.github.io/js/search.js" defer></script>

  
</body>
</html>
